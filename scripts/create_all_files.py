__author__ = 'Florian Wörz and Jan-Hendrik Lorenz'
__copyright__ = 'Copyright (c) 2021'
__version__ = '1.0'
__status__ = 'Prototype'
__description__ = 'Creates all instances, resolvents, and modified instances as explained in the paper [LW20b]'

# Specify the standard value for verbose [True/False].
# If verbose = True, print-statements will tell the user about the progress of generation.
verbose = True

if verbose:
    print('=' * 80)
    print('Authors: ' + __author__)
    print('Copyright: ' + __copyright__)
    print('Version: ' + __version__)
    print('Status: ' + __status__)
    print('Description: ' + __description__)
    print('=' * 80)



import argparse
import os
import random
import shutil
import sys
sys.path.append('./creator/')
sys.path.append('./resolution/')

import pyximport; pyximport.install(setup_args={})
from creator.base_instance_creator import create_instances
from resolution.main import resolve_and_write
from creator.mod_instance import modify_instance

# Sample call (which works quickly): python3 create_all_files.py -ns 10 11 -r 2.0 --more -t 2 -M 8

def main(N=10, ns=None, r=None, k=3, s=42, output_base_path="./root", ps=None, q=None, more=False, converge=True, times=2, max_length=4, shuffle=True, M=5000, c=None, E=None, config_file_contents=None):

    # These conditions will also be tested in base_instance_creator.py
    # However, we will use ns to create the basic folder structure, what we will do before calling base_instance_creator.py

    if not hasattr(ns, '__iter__'):
        raise TypeError("ns has to be iterable.")

    if not all(isinstance(n, int) for n in ns):
        raise TypeError('ns has to be a list of integers.')

    if not all(n > 0 for n in ns):
        raise ValueError('All ns have to be greater than zero.')

    if E is None:
        E = [0.1]

    if not hasattr(E, '__iter__'):
        raise TypeError("E has to be iterable.")

    if not all(isinstance(entry, int) for entry in E) and not all(isinstance(entry, float) for entry in E):
        raise TypeError('E has to be a list of integers or a list of floats (not mixed).')

    if not all(entry > 0 for entry in E):
        raise ValueError('All entries in E have to be greater than zero.')

    #----------------------------------------------------------------
    # Create the very basic folder structure (to be continued later)
    #----------------------------------------------------------------

    # Specification of the root folder name
    root_folder = output_base_path

    # Check if root folder already exists (prevents uncareful overwriting of files and possible statistics)
    if os.path.exists(root_folder):
        print("WARNING: The specified root folder (or a file with that name) already exists!")
        print("If you continue *everything* in this folder will be overwritten.")
        answer = query_yes_no(question="Do you want to continue?", default=None)
        if answer:
            print("All contents will now be overwritten...")
            shutil.rmtree(root_folder)
        else:
            print("Aborting the programm!")
            quit()

    # Specification of the other folder names
    instances_folder = "instances"
    resolvents_folder = "resolvents"
    mod_folder = "mod"

    instances_folder_path = os.path.join(root_folder, instances_folder)
    resolvents_folder_path = os.path.join(root_folder, resolvents_folder)
    mod_folder_path = os.path.join(root_folder, mod_folder)

    # Example:
    #
    # root_folder/
    # ├── instances_folder/ 
    # │   ├── n100/
    # │   │   └── N files
    # │   ├── n200/
    # │   └── n300/
    # ├── resolvents_folder/
    # │   ├── n100/
    # │   │   └── N files
    # │   ├── n200/
    # │   └── n300/
    # └── mod_folder/
    #     ├── n100/
    #     ├── n200/
    #     │   ├── {instance_name_1}/
    #     │   │   └── M files generated by combining the instance with M differently sampled resolvent subsets
    #     │   ├── ...
    #     │   └── {instance_name_N}/
    #     └── n300/


    # Create the folders as specified above (the n{n}-folders will be created by base_instance_creator.py)
    os.makedirs(instances_folder_path, exist_ok=True)
    os.makedirs(resolvents_folder_path, exist_ok=True)
    os.makedirs(mod_folder_path, exist_ok=True)

    for n in ns:
        os.makedirs(os.path.join(resolvents_folder_path, f"n{n}"), exist_ok=True)
        os.makedirs(os.path.join(mod_folder_path, f"n{n}"), exist_ok=True)

    #----------------------------------------------------------------
    # Write a file in the root_folder with the parameters used
    #----------------------------------------------------------------

    config_file = "configs.config"

    if config_file_contents is not None: # i.e., create_all_files.py was called via the command line
        f = open(os.path.join(root_folder, config_file), "w")
        for line in config_file_contents:
            f.write(line)        
        f.close()

    #----------------------------------------------------------------
    # Create all N base instance in each `ns`-subfolder
    #----------------------------------------------------------------

    create_instances(ns, r, N, k, s, instances_folder_path, ps, q)

    if verbose:
        print("All base instances were successfully created.")

    #----------------------------------------------------------------
    # Create the corresponding {instance} folders
    #----------------------------------------------------------------

    for n in ns:
        dir = os.path.join(instances_folder_path, f"n{n}")
        for file in os.listdir(dir):
            # We don't want the folders to end with ".cnf", thus we use os.path.splittext(folderpath)[0]
            os.makedirs(os.path.splitext(os.path.join(os.path.join(mod_folder_path, f"n{n}"), file))[0], exist_ok=True)

    #----------------------------------------------------------------
    # Apply resolution to all files
    #----------------------------------------------------------------

    for n in ns:
        dir = os.path.join(instances_folder_path, f"n{n}")
        for file in os.listdir(dir):
            print(f"Starting resolution for file {file}")
            resolve_and_write(formula=os.path.join(dir, file), output_path=os.path.join(resolvents_folder_path, f"n{n}"), converge=converge, more=more, max_length=max_length, times=times)

    if verbose:
        print("All resolvents files were successfully created.")

    #----------------------------------------------------------------
    # Generate modified files
    #----------------------------------------------------------------

    i = 1
    for n in ns:
        dir = os.path.join(instances_folder_path, f"n{n}")
        for file in os.listdir(dir):
            orig = os.path.join(dir, file)
            res = os.path.join(os.path.join(resolvents_folder_path, f"n{n}"), os.path.splitext(file)[0] + ".resolvents")            
            out = os.path.join(os.path.join(mod_folder_path, f"n{n}"), os.path.splitext(file)[0])
            for e in E:
                modify_instance(orig=orig, resolvents=res, seed=s+i, M=M, outputPath=out, p=c, E=e, shuffle=shuffle)
                i += 1
                if verbose:
                    print("Generating modified files w.r.t.:", res)

    if verbose:
        print("All modified instances were successfully created.")
        print('=' * 80)
        print("The program finished successfully.")
        print('=' * 80)


def query_yes_no(question, default="None"):
    """Ask a yes/no question via input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ja": True, "j": True,
             "no": False, "n": False, "nein": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        print(question + prompt)
        choice = input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            print("Please respond with 'yes' or 'no'.\n")



#########################################################################
######################  if __name__ == '__main__' #######################          
#########################################################################



if __name__ == '__main__':

    parser = argparse.ArgumentParser()

    parser.add_argument("-N", type=int, default=10, help="Specifies how many formulas of each size are generated.")
    parser.add_argument("-ns", nargs='+', type=int, default=None, help="Specifies the number of variables in the formulas.")
    parser.add_argument("-r", type=float, default=None, help="Specifies the clause-to-variable ratio in the formulas.")    
    parser.add_argument("-k", type=int, default=3, help="Specifies the k-value of the formula.")
    parser.add_argument("-s", type=int, default=42, help="The seed to initialize the random number generator.")
    parser.add_argument("-o", "--output_base_path", type=str, default='./root', help="The output-path to save the generated files.")
    parser.add_argument("-ps", type=float, default=None, nargs='+', help="Specify the p-values as described in the paper.....")
    parser.add_argument("-q", type=float, default=None, help="Specifies the q-value. The p-values can be determined from q.")
    parser.add_argument("--more", default=False, action="store_true" , help="More resolution rounds?")
    parser.add_argument("--converge", default=True, action="store_true" , help="Perform resolution until no new clauses are added?")
    parser.add_argument('-t', '--times', default=2, type=int, help="The number of resolution rounds. Only used if --more is used.")
    parser.add_argument('-l', '--max_length', default=4, type=int, help="The maximal length.")
    parser.add_argument("--shuffle", default=True, action="store_true" , help="Shuffle the clauses before writing to the file.")  
    parser.add_argument("-M", type=int, default=5000, help="Specifies how many new files are generated.")
    parser.add_argument("-c", type=float, default=None, help="Specifies the probability/chance for adding each resolvent.")  
    parser.add_argument("-E", nargs='+', type=float, default=None, help="Specifies the expectation (old: probability) for adding each resolvent w.r.t. the number of original clauses.")    

    args = parser.parse_args()

    # Prepare the contents of the config-file
    options = vars(args)

    config_file_contents = []

    config_file_contents.append("This folder structure and all files contained in them was created as follows:\n")
    config_file_contents.append("\n")
    config_file_contents.append("Call made in terminal:\npython3 {0}\n".format(" ".join([x for x in sys.argv])))
    config_file_contents.append("\n")
    config_file_contents.append("All settings used:\n")
    for i,j in vars(args).items():
        config_file_contents.append("{0}: {1}\n".format(i,j))

    main(N=args.N, ns=args.ns, r=args.r, k=args.k, s=args.s, output_base_path=args.output_base_path, ps=args.ps, q=args.q, more=args.more, converge=args.converge, times=args.times, max_length=args.max_length, shuffle=args.shuffle, M=args.M, c=args.c, E=args.E, config_file_contents=config_file_contents)


