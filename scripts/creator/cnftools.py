"""Module for building and manipulating CNF formulas, and outputting them in DIMACS
"""

default_header = "This file was generated by Anony Mous and In Cognito.\n"

class CNF(object):
    def __init__(self, header=None): 

        # If none header is specified, use the default header
        self.header = header if header != None else default_header

        # Initial empty formula
        self.clauses = []

        # Set up variable indices to variable names correspondence
        # We index the first variable with 1.
        self.index2name = [None]
        self.name2index = dict()

    #
    # Implementation of some standard methods
    #

    def __iter__(self):
        """Iterates over all clauses of the CNF
        """
        for cls in self._clauses:
            #assert self._coherent
            yield self._uncompress_clause(cls)

    def __str__(self):
        """String representation of the formula
        """
        #assert self._coherent
        return self._header

    def __len__(self):
        """Number of clauses in the formula
        """
        return len(self.clauses)

    #
    # Internal implementation methods, use at your own risk!
    #

    def _uncompress_clause(self, clause):
        """(INTERNAL USE) Uncompress a clause from the numeric representation.

        Arguments:
        - `clause`: clause to be uncompressed

        >>> c=CNF()
        >>> c.add_clause([(True,"x"),(False,"y")])
        >>> print(c._uncompress_clause([-1,-2]))
        [(False, 'x'), (False, 'y')]
        """
        return [(l > 0, self.index2name[abs(l)]) for l in clause]

    def _compress_clause(self, clause):
        """Convert a clause to its numeric representation.

        For reason of efficiency, clauses are memorized as tuples of
        integers. Each integer correspond to a variable, with sign +1
        or -1 depending whether it represents a positive or negative
        literal. The correspondence between the numbers and the
        variables names depends on the formula itself

        Parameters
        ----------
        clause: list of pairs
            a clause, in the form of a list of literals, which are
            pairs (bool,string).

        Returns
        -------
        a tuple of int

        Examples
        --------
        >>> c=CNF()
        >>> c.add_clause([(True,"x"),(False,"y")])
        >>> print(c._compress_clause([(False, 'x'), (False, 'y')]))
        (-1, -2)

        """
        return tuple((1 if p else -1) * self.name2index[n] for p, n in clause)

    def _add_compressed_clauses(self, clauses):
        """(INTERNAL USE) Add to the CNF a list of compressed clauses.

        This method uses the internal compressed clause representation
        to add a large batch of data  into the CNF.  It does not check
        for internal  coherence conditions,  and it  does not  need to
        convert between  internal and external  clause representation,
        so it  is very fast.   When assertions  are tested, a  call to
        this method will  disable the standard API, since  the CNF can
        be in an inconsistent state.

        Whenever the high level API is used with an inconsisten state
        the code will fail some assertion.

        In particular it does not check if the indexes correspond to a
        variable in the formula.

        To test consistency and re-enable the API, please call method
        `CNF._check_coherence`.

        Arguments:
        - `clauses`: a sequence of compressed clauses.

        >>> c=CNF()

        We add the variables in advance, so that the internal status
        stays coherent.

        >>> c.add_variable("x")
        >>> c.add_variable("y")
        >>> c.add_variable("z")

        When we add some compressed clauses, we need to test the
        internal status of the object. If the test is positive, then
        the high level API is available again.

        >>> c._add_compressed_clauses([[-1,2,3],[-2,1],[1,-3]])
        >>> c._check_coherence()
        True
        >>> print(c.dimacs(export_header=False))
        p cnf 3 3
        -1 2 3 0
        -2 1 0
        1 -3 0

        If we call the internal API several times, we need to test the
        object only once.

        >>> c._add_compressed_clauses([[-2,-3]])
        >>> c._add_compressed_clauses([[-1, 2]])
        >>> c._check_coherence()
        True
        >>> print(c.dimacs(export_header=False))
        p cnf 3 5
        -1 2 3 0
        -2 1 0
        1 -3 0
        -2 -3 0
        -1 2 0
        """
        self._coherent = False
        self.clauses.extend(tuple(c) for c in clauses)

    def _check_coherence(self, force=False):
        """Check if the formula is internally consistent.

        Certain fast manipulation methods are not safe if used
        incorrectly, so the CNF object may be corrupted. This method
        tests if that was not the case.

        Arguments:
        - `force`: force check even if the formula claims coherence

        >>> c=CNF()
        >>> c.add_variable("x")
        >>> c.add_variable("y")

        We add clauses mentioning three variables, and the formula is
        not coherent.

        >>> c._add_compressed_clauses([(-1,2),(1,-2),(1,3)])
        >>> c._check_coherence()
        False

        We cannot use the API now

        >>> c.clauses()
        Traceback (most recent call last):
        AssertionError
        """
        if not force and self._coherent:
            return True

        varindex = self.name2index
        varnames = self.index2name

        # number of variables and clauses
        N = len(varindex.keys())

        # Consistency in the variable dictionary
        if N != len(varnames) - 1:
            return False

        for i in range(1, N + 1):
            if varindex[varnames[i]] != i:
                return False

        # Count clauses and check literal representation
        for clause in self.clauses:
            for literal in clause:
                if not 0 < abs(literal) <= N:
                    return False

        # formula passed all tests
        self._coherent = True
        return True

    #
    # High level API: build the CNF
    #

    def add_clause(self,
                   clause,
                   allow_literal_repetitions=False,
                   allow_opposite_literals=False):
        """Add a clause to the CNF.
        E.g. (not x3) or x4 or (not x2) is encoded as
             [(False,u"x3"),(True,u"x4"),(False,u"x2")]



        allow_literal_repetitions: bool, optional
            True if and only if the clause can have repeated literal.

            Useful for sanity check. If the flag is `False` and the
            clause contain two copies of the same literal, then
            `ValueError` is raised. (default: False)

        allow_opposite_literals: bool, optional
            True if and only if the clause can have opposite literal.

            Useful for sanity check. If the flag is `False` and the
            clause contain two opposite literals, then `ValueError`
            is raised. (default: False)

        auto_variables: bool, optional
            If `True` the clause can contain new variables.

            New variables occurring in the clause will be added to the
            formula, unless the flag is `False`. In that case when
            a clause contains an unknow variables, `ValueError` is
            raised. (default: True)

        strict: bool, optional
            If `True` impose restrictions on the clause.

            Setting this to `True` is equivalent to set
            `literal_repetitions`, `opposite_literals`,
            `auto_variables` to `False`. In case of conflicting
            settings, the most restrictive one holds.
            (default: False)
        """
        #assert self._coherent

        # A clause must be an immutable object
        try:
            hash(tuple(clause))
        except TypeError:
            raise TypeError("%s is not a well formatted clause" % clause)





        # Check literal repetitions
        if (not allow_literal_repetitions) and len(set(clause)) != len(clause):
            raise ValueError(
                "Forbidden repeated literals in clause {}".format(clause))

        # Check opposite literals
        if not allow_opposite_literals:
            positive = set([v for (p, v) in clause if p])
            negative = set([v for (p, v) in clause if not p])
            if len(positive & negative) > 0:
                emsg = "{ " + ", ".join(positive & negative) + " }"
                raise ValueError(
                    "Following variable occur with opposite literals: {}".
                    format(emsg))

        # Add the compressed clause
        try:
            self.clauses.append(self._compress_clause(clause))
        except KeyError as error:            
            for _, var in clause:
                self.add_variable(var)
            self.clauses.append(self._compress_clause(clause))



    def add_variable(self, var, description=None):
        """Add a variable to the formula (if not already resent).

        

        Parameters
        ----------
        var: hashable
             the variable name to be added/updated.
        """
        try:
            if not var in self.name2index:
                # name correpsond to the last variable so far
                self.index2name.append(var)
                self.name2index[var] = len(self.index2name) - 1
        except TypeError:
            raise TypeError("%s is not a legal variable name" % var)



    #
    # High level API: read the CNF
    #
    def variables(self):
        """Returns (a copy of) the list of variable names.
        """
        #assert self._coherent
        vars_iterator = iter(self.index2name)
        next(vars_iterator)
        return vars_iterator

    def clauses(self):
        """Return the list of clauses
        """
        #assert self._coherent
        return self.__iter__()

    def dimacs(self, export_header=True, extra_text=None):
        """Produce the dimacs encoding of the formula

        The formula is rendered in the DIMACS format for CNF formulas,
        which is a particularly popular input format for SAT solvers [1]_.

        .. note:: By default the DIMACS output is *ascii* encoded,
                  with non-ascii characters replaced.

        Parameters
        ----------
        export_header : bool
            determines whether the formula header should be inserted as
            a comment in the DIMACS output.

        extra_text : str, optional
            Additional text attached to the header

        Returns
        -------
        string
            the string contains the Dimacs code


        Examples
        --------
        >>> c=CNF([[(False,"x_1"),(True,"x_2"),(False,"x_3")],\
                   [(False,"x_2"),(False,"x_4")], \
                   [(True,"x_2"),(True,"x_3"),(False,"x_4")]])
        >>> print(c.dimacs(export_header=False))
        p cnf 4 3
        -1 2 -3 0
        -2 -4 0
        2 3 -4 0

        >>> c=CNF()
        >>> print(c.dimacs(export_header=False))
        p cnf 0 0
        <BLANKLINE>

        References
        ----------
        .. [1] http://www.satlib.org/Benchmarks/SAT/satformat.ps

        """
        from io import StringIO
        output = StringIO()
        self._dimacs_dump_clauses(output, export_header, extra_text)
        return output.getvalue()

    def _dimacs_dump_clauses(self,
                             output=None,
                             export_header=True,
                             extra_text=None):
        """Dump the dimacs encoding of the formula to the file-like output

        This is for internal use only. It produces the dimacs output
        of the clauses, and write then on the output buffer, which is
        tipically a StringIO.
        """
        #assert self._coherent

        # Count the number of variables and clauses
        n = len(self.index2name) - 1
        m = len(self)

        # Produce header in ascii compatible format
        if export_header:
            # remove non ascii text
            ascii_header = self.header.encode('ascii', errors='replace')
            ascii_header = ascii_header.decode('ascii')
            for line in ascii_header.split("\n")[:-1]:
                output.write(("c " + line).rstrip() + "\n")

            # remove non ascii text
            if extra_text is not None:
                ascii_extra = extra_text.encode('ascii', errors='replace')
                ascii_extra = ascii_extra.decode('ascii')
                for line in ascii_extra.split("\n"):
                    output.write(("c " + line).rstrip() + "\n")

        # Formula specification
        output.write("p cnf {0} {1}".format(n, m))

        if len(self.clauses) == 0:
            output.write("\n")  # this newline makes `lingeling` solver happy

        # Clauses
        for cls in self.clauses:
            output.write("\n" + " ".join([str(l) for l in cls + (0, )]))

